---
title: 《汇编语言》 读书笔记
categories: 计算机
tags:
  - 汇编
  - 读书笔记
date: 2024-08-26
description: 
image: 
weight: 1
draft: false
lastmod: 2024-10-28T17:59:35+08:00
---
## 第 1 章 基础知识

在汇编层面，指令和数据别无二致，都是一堆二进制数据。

那么，CPU 是如何分辨此时的二进制代码应当识别为数据还是指令呢？

答案是 IP 寄存器。IP 寄存器指向的数据即为指令。

CPU 和内存共同组成了计算机的“大脑”，二者之间通过总线进行连接。总线根据用途，可以分为：
1. 用于 CPU 告诉内存要取的数据地址的**地址线**；
2. 用于内存向 CPU 传递数据的**数据线**；
3. 用于 CPU 向内存传递读写指令的**控制线**。

CPU 的所有指令以及数据，都是通过总线在内存中进行访问的，但物理上各种数据的存储又是分开的，比如显卡的显存，主存储器的 RAM 等（这些都是运行时的内存）。因此，很容易联想到，这些物理上的内存一定通过某种方式联系了起来，供 CPU 使用。具体表现为，CPU 使用的是虚拟内存地址，将逻辑地址映射到物理地址上。

其中，虚拟内存地址的映射是通过内存管理单元（MMU, Memory Management Unit）来实现的。MMU 负责将 CPU 的逻辑地址（虚拟地址）映射到物理地址，并管理虚拟内存的分页、段等操作。这一过程涉及到页表（Page Table）的使用，CPU 通过查找页表，将虚拟地址转换为物理地址，最终访问到具体的物理内存。


## 第 2 章 寄存器

8086 cpu 有 14 个寄存器，其中通用寄存器有 4 个：ax、bx、cx、dx，这四个都可以分为上下进行使用，例如 ax 可以分为 al、ah。

![image.png](https://raw.githubusercontent.com/oLd-Y/PicGoPictures/main/20240909192019.png)
8086 cpu （16 位）可以处理两种类型的数据：
- 字节，1 字节 = 8 bit
- 字，1 字 = 2 字节 = 16 bit

cs 和 ip 是最重要的寄存器。CPU 通过 cs:ip 访问所有的指令，指令的位置为`基址 + 偏移`，即 `cs * 16 + ip`。

常用指令：
- `jmp 2AE3:3`，令 cs = 2AE3，ip = 3。
- `mov ax, bx`，将 bx 的值赋给 ax。
- `jmp 4`，令 ip = 4，cs 不变。

## 第 3 章 寄存器（内存访问）

![image.png](https://raw.githubusercontent.com/oLd-Y/PicGoPictures/main/20240913152935.png)
对于这张图，1 地址处的**字**型数据为 `124EH`，**字节**型数据为 `4EH`。

`mov al, [0]`：将 [0] 单元中的数据送入 al 寄存器，该数据的默认段地址为 ds 寄存器中的内容。`[0]` 表示一个偏移地址为 0 的内存单元。

`mov ds, 1000H` 是不合法的命令，`mov ds, ax` 则合法。

栈由 `ss` 寄存器 和 `sp` 指针决定， `ss:sp` 指向当前栈的栈顶。如果此时栈为空，则 `sp` 为栈顶本来应该在的内存单元地址 + 2。

`push ax` / `pop ax` 的作用为先变化 `sp` 指针，然后将 ax 中的内容压入栈中/从栈中内容弹出到 ax 中。`sp` 指针从高地址向低地址变化。

![image.png](https://raw.githubusercontent.com/oLd-Y/PicGoPictures/main/20240913201938.png)

8086 CPU 根据不同的寄存器/指针判断当前内存区域是代码、栈还是数据：
- cs:ip 指向的内容为代码段的首位。
- ds 中存放的内容就作为数据段的首位**地址**。
- ss:sp 指向的内容为栈段的栈顶。

## 第 4 章 第一个程序

一个程序编写好了之后，需要经过编译、连接，才能成为可执行文件。每个步骤执行结束之后的文件后缀分别为：
- 编写完成：`.asm`
- 编译完成：`.obj`
- 连接之后：`.exe`

连接的作用：
- 程序很大时，将多个编译后的文件连接在一起。
- 程序调用库文件中的程序时，将库文件和该文件生成的目标文件连接在一起。
- 单个文件编译之后有些内容无法直接生成机器码，这部分内容就由连接来生成机器码。

## 第 5 章 [BX]和loop指令

设 bx 中的数据为 EA，ds 中的数据为 SA，则：

- `mov ax, [bx]` 表示将 EA:SA 的数据赋给 ax。
- `mov [bx], ax` 表示将 ax 的数据送入内存 EA:SA 处。

`loop s` 表示循环标号 s 所在的代码，循环次数由 cx 寄存器决定。

指令中不只可以使用默认 ds 表示段地址，也可以使用段前缀，例如：`mov ds:[0] al`，`mov ax, es:[bx]` 等。

## 第 6 章 包含多个段的程序

db 用于定义字节型数据，dw 用于定义字型数据。

`dw 0123h, 0456h` 定义两个 16 进制数据  0123，0456。

如果先定义数据，再编写程序，则 CPU 指执行时最先接触的就是数据而非程序。因此，我们通过 `end` 指明程序的入口，例如 `end start` 指明入口程序的标号为 `start`，程序执行的时候，CPU 就会自动将标号 start 程序所在的地址作为程序的起始地址。

dw 命令既可以说它定义了数据，也可以说它开辟了空间。

`mov ds data`，data 为段标号。这句是将 data 所在的段地址赋给了 ds。

`db 'a', 'b'` 定义两个字符数据 a, b。当然实际只是 ASCII 码 65h、66h。

若是需要让 cpu 将代码段、栈段、数据段正确识别，就需要在程序运行时将段地址（cs、ss、ds）赋好、指针（ip、sp）的位置指好，例如：
```x86asm
;; 假设已提前定义好 stack 段
mov ax stack
mov ss, ax
mov sp, 20h
```

## 第 7 章 更灵活的定位内存地址的方法

`and al, 10111111B` 和 `or al, 10111111B` 进行与和或的操作。

某内存的数据如下所示：

`2000:1000 BE 00 06 00 6A 22 ......`（ds = 2000, bx = 1000）则
- 第一个字的数据地址为 `2000:1000`，值为 `00BEh`。
- 第二个字的数据地址为 `2000:1002`，值为 `0006h`。
- 而 `ds:[bx + 1]` 加的是字节，不是字，因此其值为 `0600h`。

大写字母和小写字母在二进制层面的区别为：小写字母的第 5 位为 1，而相应的大写字母的第 5 位为 0，且二者的二进制只有这里有区别。（位数从 0 开始算）

si，di 为功能和 bx 相近的寄存器。

常量、变量或者他们的结合都可以用来表示一个内存地址，例如 [5]，[bx + 4]，[bx + si]，[bx + di + 4] 等。

## 第 8 章 数据处理的两个基本问题

指令执行前，可能在的位置有 3 个：CPU 内部、内存、端口。

汇编中的数据位置有 3 种表达方式：
- 立即数，执行前在 CPU 的指令缓冲器中，例如 `mov ax 1`。
- 寄存器，执行前在 CPU 的寄存器中，例如 `mov ax，bx`。
- 通过寄存器给出的偏移地址指向内存中的地址，执行前在内存中，例如 `mov ax，[bx + 8]`

8086 cpu 中只有 4 个寄存器可以放在中括号 `[]` 中表示内存地址，分别是 bx、di、si、bp。其中：
1. 当寄存器组合出现的时候，只有以下四种组合合法：`bx 和 di`、`bx 和 si`、`bp 和 di`、`bp 和 si`。
2. `[bp]` 的段地址默认在 ss 中，而非 ds 中。

常用寻址方式小结：
![image.png](https://raw.githubusercontent.com/oLd-Y/PicGoPictures/main/20240925115228.png)
如何确定当前 CPU 要操作的是字型数据还是字节型数据？有如下 3 种方式：
- 通过寄存品名指明，例如 ax 是字的，al 是字节的。
- 通过关键字指明，例如 `mov word ptr [bx]` 指明是字型数据，`mov byte ptr [bx]` 则指明是字节型数据。

设被除数为 x，除数为 y，则要表达 x / y，其汇编指令为 `div y`，除数存储在内存单元或者一个寄存器中，而被除数则存储在 `ax` 或者 `ax` 和 `dx` 中。
- 若 x 为 8 位，则 y 为 16 位，默认存放在 ax 中。
- 若 x 为 16 位，则 y 为 32 位，默认存放在 ax 和 dx 中，dx 放高 16 位，ax 放低 16 位。

`dd 1` 定义一个双字型的数据 `00000001H`。

`dup` 配合 `db`，`dw`，`dd` 等伪指令使用，用于重复创建相同的数据。例如 `db dup 3 (0)` 创建 3 个字节类型的 0。

## 第 9 章 转移指令的原理

可以修改 ip 或 cs & ip 的指令称为转移指令。主要分为：
- 无条件转移指令(如：jmp)
- 条件转移指令
- 循环指令(如：loop)
- 过程
- 中断

转移行为分为：
- 段内转移（只修改 ip），如 `jmp ax`。根据修改的 ip 大小，段内转移又分为：
	- 短转移（-128 ~ 127）。
	- 近转移（-32768 ~ 32767）。
- 段间转移（同时修改 cs & ip）如 `jmp 1000:0`。

`mov ax, offset start`，offset 的作用是获取 start 标号所在的偏移地址。

`jmp short s`，short 表明此次 jmp 进行的是短转移，用 s 的偏移地址修改 ip 指针。

jmp 命令并不是通过目的地址进行跳转，而是通过相对量进行位移（相对量通过 `标号所在地址` 与 `jmp 后一条命令所在地址` 的地址之差获取）。使用相对地址跳转而不是直接使用绝对地址的好处在于，如果程序的在内存中的位置更改了，不用把所有的地址都一并更改。

`jmp far ptr s`，far ptr 表明此次 jmp 进行的是段间转移（远转移），用 s 的段地址和偏移地址修改 cs 和 ip。

`jmp word ptr ds:[0]`，word 表明在 ds:[0] 处存放了一个字的内容，用这个内容修改 ip 的值。

`jcxz s`，jcxz 是一个条件转移，只有当 cx == 0 的时候才跳转到标号 s 所在位置。

`loop s`，所有循环都是短转移，只有当 cx == 0 的时候才跳转到标号 s 所在位置。

## 第 10 章 call 和 ret 指令

`ret` 相当于 `pop IP`，即把栈中的数据弹到 IP 指针中。

`retf` 相当于 `pop IP` 再 `pop CS`，即把栈中的数据弹到 IP 指针之后再弹一次数据到 CS 中。

`call 标号` 的就是调用函数， 作用是先将当前的 IP 或者 CS & IP 压栈，然后再跳到标号所在的位置执行程序。根据是否跨段决定是否从栈中弹出 CS 的值，例如：
1. `call 标号`，相当于 `push IP`，`jmp near ptr 标号`。
2. `call far ptr 标号`，相当于 `push CS`，`push IP`，`jmp far ptr 标号`。
3. `call al`，相当于 `push IP`，`jmp al`。
4. `call word ptr [4]`，相当于 `push IP`，`jmp word ptr [4]`。

`call` 和 `ret` 一般配合使用，call 调用函数，在这之前将当前执行位置压栈，等执行完毕之后使用 ret 把栈中的内容返回。

`mul bl` 或者 `mul bx`，mul 表示乘法，两个乘数要么都是 16 位，要么都是 8 位。除了 mul 后的操作数，另一个乘数默认在 ax 中或者 al 中（跟位数有关）。8 位乘法的结果默认放在 ax 中，16 位默认高位在 dx 中，低位在 ax 中。

父子程序可能使用同一个寄存器，因此**子程序**的最开头需要将这些信息入栈保存起来，结尾时候出栈返回。

## 第 11 章 标志寄存器

即 flag，每一位都有作用。

- 第 6 位，zf，0 标志位。zf = 1，则结果为 0。
- 第 2 位，pf，奇偶标志位。pf = 1，则结果里位为 1 的个数为偶数。
- 第 7 位，sf，符号标志位。sf = 1，则结果为负。
- 第 0 位，cf，进位标志位。cf = 1，则向高位借位或者进位了。
- 第 11 位，of，溢出标志位。of = 1，则发生了溢出。
- 第 10 位，df，方向标志位。df = 1，则每次操作之后 si、di 递减。

adc 比 add 多加了一个 cf，sbb 比 sub 多减了一个 cf。

cmp 只做减法，仅影响标志位，不保存结果。

常用条件转移：

![image.png](https://raw.githubusercontent.com/oLd-Y/PicGoPictures/main/20241028173246.png)


`movsb` 等价于将 ds:si 地址上的值赋给 es:di 地址。

`cld` 将 df 置 0，std 将 df 置 1 。

pushf 将 flag 的值压栈，popf 则出栈到 flag 中。

debug 中的 标志位表示：

![image.png](https://raw.githubusercontent.com/oLd-Y/PicGoPictures/main/20241028175919.png)

由于时间不太够用且继续深挖对当前帮助不大，此笔记太监。