---
title: 《汇编语言》 读书笔记
categories: 计算机
tags:
  - 汇编
  - 读书笔记
date: 2024-08-26
description: 
image: 
weight: 1
draft: false
lastmod: 2024-09-25T12:10:40+08:00
---
## 第 1 章 基础知识

在汇编层面，指令和数据别无二致，都是一堆二进制数据。

那么，CPU 是如何分辨此时的二进制代码应当识别为数据还是指令呢？

答案是 IP 寄存器。IP 寄存器指向的数据即为指令。

CPU 和内存共同组成了计算机的“大脑”，二者之间通过总线进行连接。总线根据用途，可以分为：
1. 用于 CPU 告诉内存要取的数据地址的**地址线**；
2. 用于内存向 CPU 传递数据的**数据线**；
3. 用于 CPU 向内存传递读写指令的**控制线**。

CPU 的所有指令以及数据，都是通过总线在内存中进行访问的，但物理上各种数据的存储又是分开的，比如显卡的显存，主存储器的 RAM 等（这些都是运行时的内存）。因此，很容易联想到，这些物理上的内存一定通过某种方式联系了起来，供 CPU 使用。具体表现为，CPU 使用的是虚拟内存地址，将逻辑地址映射到物理地址上。

其中，虚拟内存地址的映射是通过内存管理单元（MMU, Memory Management Unit）来实现的。MMU 负责将 CPU 的逻辑地址（虚拟地址）映射到物理地址，并管理虚拟内存的分页、段等操作。这一过程涉及到页表（Page Table）的使用，CPU 通过查找页表，将虚拟地址转换为物理地址，最终访问到具体的物理内存。

## 第 2 章 寄存器

8086 cpu 有 14 个寄存器，其中通用寄存器有 4 个：ax、bx、cx、dx，这四个都可以分为上下进行使用，例如 ax 可以分为 al、ah。

![image.png](https://raw.githubusercontent.com/oLd-Y/PicGoPictures/main/20240909192019.png)
8086 cpu （16 位）可以处理两种类型的数据：
- 字节，1 字节 = 8 bit
- 字，1 字 = 2 字节 = 16 bit

cs 和 ip 是最重要的寄存器。CPU 通过 cs:ip 访问所有的指令，指令的位置为`基址 + 偏移`，即 `cs * 16 + ip`。

常用指令：
- `jmp 2AE3:3`，令 cs = 2AE3，ip = 3。
- `mov ax, bx`，将 bx 的值赋给 ax。
- `jmp 4`，令 ip = 4，cs 不变。

## 第 3 章 寄存器（内存访问）

![image.png](https://raw.githubusercontent.com/oLd-Y/PicGoPictures/main/20240913152935.png)
对于这张图，1 地址处的**字**型数据为 `124EH`，**字节**型数据为 `4EH`。

`mov al, [0]`：将 [0] 单元中的数据送入 al 寄存器，该数据的默认段地址为 ds 寄存器中的内容。`[0]` 表示一个偏移地址为 0 的内存单元。

`mov ds, 1000H` 是不合法的命令，`mov ds, ax` 则合法。

栈由 `ss` 寄存器 和 `sp` 指针决定， `ss:sp` 指向当前栈的栈顶。如果此时栈为空，则 `sp` 为栈顶本来应该在的内存单元地址 + 2。

`push ax` 和 `pop ax` 的作用分别为先变化 `sp` 指针，然后将内容从栈中弹出以及压入栈中。`sp` 指针从高地址向低地址变化。

![image.png](https://raw.githubusercontent.com/oLd-Y/PicGoPictures/main/20240913201938.png)

8086 CPU 根据不同的寄存器/指针判断当前内存区域是代码、栈还是数据：
- cs:ip 指向的内容为代码段的首位。
- ds 中存放的内容就作为数据段的首位**地址**。
- ss:sp 指向的内容为栈段的栈顶。

## 第 4 章 第一个程序

一个程序编写好了之后，需要经过编译、连接，才能成为可执行文件。每个步骤执行结束之后的文件后缀分别为：
- 编写完成：`.asm`
- 编译完成：`.obj`
- 连接之后：`.exe`

连接的作用：
- 程序很大时，将多个编译后的文件连接在一起。
- 程序调用库文件中的程序时，将库文件和该文件生成的目标文件连接在一起。
- 单个文件编译之后有些内容无法直接生成机器码，这部分内容就由连接来生成机器码。

## 第 5 章 [BX]和loop指令

设 bx 中的数据为 EA，ds 中的数据为 SA，则：

- `mov ax, [bx]` 表示将 EA:SA 的数据赋给 ax。
- `mov [bx], ax` 表示将 ax 的数据送入内存 EA:SA 处。

`loop s` 表示循环标号 s 所在的代码，循环次数由 cx 寄存器决定。

指令中不只可以使用默认 ds 表示段地址，也可以使用段前缀，例如：`mov ds:[0] al`，`mov ax, es:[bx]` 等。

## 第 6 章 包含多个段的程序

db 用于定义字节型数据，dw 用于定义字型数据。

`dw 0123h, 0456h` 定义两个 16 进制数据  0123，0456。

如果先定义数据，再编写程序，则 CPU 指执行时最先接触的就是数据而非程序。因此，我们通过 `end` 指明程序的入口，例如 `end start` 指明入口程序的标号为 `start`，程序执行的时候，CPU 就会自动将标号 start 程序所在的地址作为程序的起始地址。

dw 命令既可以说它定义了数据，也可以说它开辟了空间。

`mov ds data`，data 为段标号。这句是将 data 所在的段地址赋给了 ds。

`db 'a', 'b'` 定义两个字符数据 a, b。当然实际只是 ASCII 码 65h、66h。

若是需要让 cpu 将代码段、栈段、数据段正确识别，就需要在程序运行时将段地址（cs、ss、ds）赋好、指针（ip、sp）的位置指好，例如：
```x86asm
;; 假设已提前定义好 stack 段
mov ax stack
mov ss, ax
mov sp, 20h
```

## 第 7 章 更灵活的定位内存地址的方法

`and al, 10111111B` 和 `or al, 10111111B` 进行与和或的操作。

某内存的数据如下所示：

`2000:1000 BE 00 06 00 6A 22 ......`（ds = 2000, bx = 1000）则
- 第一个字的数据地址为 `2000:1000`，值为 `00BEh`。
- 第二个字的数据地址为 `2000:1002`，值为 `0006h`。
- 而 `ds:[bx + 1]` 加的是字节，不是字，因此其值为 `0600h`。

大写字母和小写字母在二进制层面的区别为：小写字母的第 5 位为 1，而相应的大写字母的第 5 位为 0，且二者的二进制只有这里有区别。（位数从 0 开始算）

si，di 为功能和 bx 相近的寄存器。

常量、变量或者他们的结合都可以用来表示一个内存地址，例如 [5]，[bx + 4]，[bx + si]，[bx + di + 4] 等。

## 第 8 章 数据处理的两个基本问题

指令执行前，可能在的位置有 3 个：CPU 内部、

8086 cpu 中只有 4 个寄存器可以放在中括号 `[]` 中表示内存地址，分别是 bx、di、si、bp。其中：
1. 当寄存器组合出现的时候，只有以下四种组合合法：`bx 和 di`、`bx 和 si`、`bp 和 di`、`bp 和 si`。
2. `[bp]` 的段地址默认在 ss 中，而非 ds 中。

常用寻址方式小结：
![image.png](https://raw.githubusercontent.com/oLd-Y/PicGoPictures/main/20240925115228.png)
